import base64
import json
import logging
import os
import random
import re
import string
import sys

import click
import paho.mqtt.client as mqtt

logger = logging.getLogger()
handler = logging.StreamHandler()
formatter = logging.Formatter(
    '%(asctime)s %(name)-12s %(levelname)-8s %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.WARNING)


class OpenTestbedClient(object):

    def __init__(self, testbed, broker):
        self.testbed = testbed
        self.broker = broker

        self.connected = False
        self.queue = []
        self.token = ''.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(10))

        self.mqttopic_testbed_prefix = '{0}/deviceType/'.format(self.testbed)

        self.mqttclient = mqtt.Client('cli{}'.format(self.token))
        self.mqttclient.enable_logger()

        self.mqttclient.on_connect = self._on_mqtt_connect
        self.mqttclient.on_message = self._on_mqtt_message
        self.mqttclient.connect(broker)

        self.token_nr = 0

    def loop(self):
        logger.info("Waiting for messages. Press CTRL+C to exit.")

        try:

            self.mqttclient.loop_forever()
        except KeyboardInterrupt:
            pass

        self.mqttclient.loop_stop()

    def _on_mqtt_connect(self, client, userdata, flags, rc):
        client.subscribe('{0}#'.format(self.mqttopic_testbed_prefix))

        self.connected = True

        logger.debug("Connected to MQTT")

        for publish_args in self.queue:
            self.mqttclient.publish(**publish_args)
            logger.debug("Published Queued message %s", str(publish_args))

        self.queue = None

    def _on_mqtt_message(self, client, userdata, message):
        try:
            m = re.search('{0}/deviceType/([a-z]+)/deviceId/([\w,\-]+)/resp/([a-z]+)'.format(self.testbed),
                          message.topic)

            if m is None:
                # skipping
                return

            deviceType = m.group(1)
            deviceId = m.group(2)
            cmd = m.group(3)

            body = json.loads(message.payload.decode("utf8"))

            if isinstance(body.get('token'), basestring) and body['token'].startswith(self.token):
                click.secho("{} {:>10s}: ".format(deviceType[0], deviceId, ), bold=True, nl=False)

                if bool(body['success']):
                    click.echo(body['returnVal'])
                else:
                    click.secho(body['exception'], fg='white', bg='red')

            else:
                logger.debug('token does not match: {} vs {} for message {}'.
                             format(body.get('token'), self.token, message.payload))
        except Exception as e:
            logger.exception("Error while handling message")

    def publish_command(self, deviceType, deviceId, cmd, **kwargs):
        msg_token = "{}{:02d}".format(self.token, self.token_nr)
        self.token_nr += 1

        topic = '{0}{1}/deviceId/{2}/cmd/{3}'.format(self.mqttopic_testbed_prefix, deviceType, deviceId, cmd)
        payload = kwargs.copy()
        payload['token'] = msg_token

        publish_args = {'topic': topic, 'payload': json.dumps(payload)}

        if self.connected:
            self.mqttclient.publish(**publish_args)
            logger.debug("Published Message %s", str(publish_args))
        else:
            self.queue.append(publish_args)


class ListenSerialClient(object):

    def __init__(self, testbed, broker, euid64):
        self.testbed = testbed
        self.broker = broker
        self.euid64 = euid64

        self.connected = False

        self.mqttopic = '{0}/deviceType/mote/deviceId/{1}/notif/frommoteserialbytes' \
            .format(self.testbed, self.euid64)

        self.token = ''.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(10))
        self.mqttclient = mqtt.Client('cliserial{}'.format(self.token))
        self.mqttclient.enable_logger()

        self.mqttclient.on_connect = self._on_mqtt_connect
        self.mqttclient.on_message = self._on_mqtt_message
        self.mqttclient.connect(broker)

        self.token_nr = 0

    def loop(self):
        logger.info("Waiting for messages. Press CTRL+C to exit.")

        try:
            self.mqttclient.loop_forever()
        except KeyboardInterrupt:
            pass

        self.mqttclient.loop_stop()

    def _on_mqtt_connect(self, client, userdata, flags, rc):
        client.subscribe(self.mqttopic)

        self.connected = True
        logger.debug("Connected to MQTT")

    def _on_mqtt_message(self, client, userdata, message):
        try:
            body = json.loads(message.payload.decode("utf8"))

            os.write(1, bytearray(body['serialbytes']))
        except Exception as e:
            logger.exception("Error while handling message")


SPECIAL_COMMANDS = ['listenserial']


@click.group()
@click.option("-t", "--testbed", required=True, envvar='OTB_TESTBED', default="opentestbed",
              type=click.Choice(['iotlab', 'opentestbed', 'wilab']))
@click.option('-b', '--broker', required=True, envvar='OTB_BROKER', help="The MQTT broker address")
@click.option('-v', '--verbose', count=True, help="Increase verbosity")
@click.pass_context
def cli(ctx, testbed, broker, verbose):
    if verbose >= 2:
        logger.setLevel(logging.DEBUG)
    elif verbose == 1:
        logger.setLevel(logging.INFO)
    else:
        logger.setLevel(logging.WARNING)

    if ctx.invoked_subcommand in SPECIAL_COMMANDS:
        ctx.obj = {'testbed': testbed, 'broker': broker}
    else:
        otbc = OpenTestbedClient(testbed, broker)
        ctx.obj = otbc


@cli.resultcallback()
@click.pass_obj
def cli_result_callback(ctx_obj, result, testbed, broker, verbose):
    if isinstance(ctx_obj, OpenTestbedClient):
        ctx_obj.loop()


@cli.command()
@click.option("--box", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.argument("message")
@click.pass_obj
def echo(client, box, message):
    """Simple echo command"""
    for b in box:
        client.publish_command('box', b, 'echo', payload=message)


@cli.command()
@click.option("--box", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.pass_obj
def status(client, box):
    """Request status of otboxes"""
    for b in box:
        client.publish_command('box', b, 'status')


@cli.command()
@click.option("--box", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.pass_obj
def discovermotes(client, box):
    """Discover motes connected to otboxes"""
    for b in box:
        client.publish_command('box', b, 'discovermotes')


# @cli.command()
# @click.option("--box", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
# @click.argument('version')
# @click.argument('url')
# @click.pass_context
# def changesoftware(ctx, box, version, url):
#     client = ctx.obj[CLIENT]
#     for b in box:
#         client.publish_command('box', b, 'changesoftware',version=version, url=url)

@cli.command()
@click.option("--box", required=True, help="The box to which to send the request")
@click.argument('location')
@click.pass_obj
def changelocation(client, box, location):
    """Change location of otbox"""
    for b in box:
        client.publish_command('box', b, 'changelocation', location)


@cli.command()
@click.option("--mote", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.argument('description')
@click.argument('url')
@click.pass_obj
def program_from_url(client, mote, description, url):
    """Flash firmware from URL"""
    for m in mote:
        client.publish_command('mote', m, 'program', description=description, url=url)


@cli.command()
@click.option("--mote", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.argument('file', type=click.Path(exists=True))
@click.pass_obj
def program_from_file(client, mote, file):
    """Flash firmware from local file"""
    with open(file, 'rb') as f:
        hex = base64.b64encode(f.read()).decode('utf8')

    for m in mote:
        client.publish_command('mote', m, 'program', description=os.path.basename(file), hex=hex)


@cli.command()
@click.option("--mote", default=['all'], multiple=True, help="The motes to which to send the request. (default: all)")
@click.argument('serialbytes', type=click.File('rb'))
@click.pass_obj
def tomoteserialbytes(client, mote, serialbytes):
    """Send data to serial port of mote"""
    bytes = []
    for i in serialbytes:
        bytes.append(ord(i))

    for m in mote:
        client.publish_command('mote', m, 'tomoteserialbytes', serialbytes=bytes)

@cli.command()
@click.option("--mote", default=['all'], multiple=True, help="The motes to which to send the request. (default: all)")
@click.pass_obj
def reset(client, mote):
    """Reset a mote via DTR and RTS signals on serial"""

    for m in mote:
        client.publish_command('mote', m, 'reset')

@cli.command()
@click.option("--mote", default=['all'], multiple=True, help="The motes to which to send the request. (default: all)")
@click.pass_obj
def disable(client, mote):
    """Remove custom firmware from mote"""

    for m in mote:
        client.publish_command('mote', m, 'disable')


RE_EUI64_FORMAT = re.compile('^' + '-'.join(['([0-9A-Fa-f]{2})'] * 8))


@cli.command()
@click.argument('mote')
@click.pass_obj
def listenserial(options, mote):
    """
    Listen to the output of mote with the given EUI64
    """
    if not RE_EUI64_FORMAT.match(mote):
        click.secho("Invalid EUI64. Must be formatted like '00-12-4b-00-09-df-2c-0f'", fg='white', bg='red')
        return False

    c = ListenSerialClient(options['testbed'], options['broker'], mote)

    c.loop()


if __name__ == '__main__':
    args = sys.argv[1:]
    cli(args)
